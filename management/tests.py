import pytest
from decimal import Decimal
from django.core.exceptions import ValidationError
from .models import Quotation, QuotationItem, Invoice, InvoiceItem
from management.forms import QuotationForm ,QuotationItemForm, InvoiceForm, InvoiceItemForm
from unittest import mock
from datetime import date, timedelta
from django.utils import timezone
from django.db import connection
import logging
from django.urls import reverse
from django.test import Client

logger = logging.getLogger(__name__)

@pytest.mark.django_db
class TestQuotationModel:

    @pytest.fixture(autouse=True)
    def reset_database(self, db):
        # This will run before each test
        Quotation.objects.all().delete()
        QuotationItem.objects.all().delete()
        # Optionally reset sequences
        with connection.cursor() as cursor:
            cursor.execute("ALTER SEQUENCE management_quotation_id_seq RESTART WITH 1;")
            cursor.execute("ALTER SEQUENCE management_quotationitem_id_seq RESTART WITH 1;")
    
    def test_database_state(self):
        """Log the initial state of the database."""
        logger.debug("Starting database state:")
        for quote in Quotation.objects.all():
            logger.debug(f"{quote.id} - {quote.quote_number}")

    def test_quotation_creation(self):
        """Test for creating a quotation."""
        try:
            quotation = Quotation(
                client_name="John Doe",
                client_email="john@example.com",
                client_address="123 Main St",
                client_phone_number="555-1234",
                tax_rate=Decimal('10.00'),
                
            )
            quotation.save()  # Explicitly save the instance

            # Call calculate_totals to update the subtotal and grand_total
            quotation.calculate_totals()
            
            # Verify that the quote number is generated by the model's logic
            assert quotation.quote_number.startswith("QUOTE-")
            assert quotation.client_name == "John Doe"
            assert quotation.client_email == "john@example.com"
            assert quotation.subtotal == 0  # Check subtotal after totals are calculated
            assert quotation.grand_total == 0  # Expected to include only labour_cost as subtotal
        except Exception as e:
            logger.error(f"Error during test: {e}")
            raise


    def test_generate_unique_quote_number(self):
        """Test that each Quotation has a unique quote number."""
        quotation1 = Quotation(
            client_name="Client One",
            client_email="client1@example.com",
            client_address="Address One",
            client_phone_number="12345"
        )
        quotation1.save()  # Save instance to persist it

        quotation2 = Quotation(
            client_name="Client Two",
            client_email="client2@example.com",
            client_address="Address Two",
            client_phone_number="67890"
        )
        quotation2.save()  # Save instance to persist it

        assert quotation1.quote_number != quotation2.quote_number

    def test_quotation_totals_calculation(self):
        """Test total calculations for a Quotation."""
        
        quotation = Quotation(
            client_name="John Doe",
            client_email="john@example.com",
            client_address="123 Main St",
            client_phone_number="555-1234",
            tax_rate=Decimal('10.00'),
            
        )
        quotation.save()  # Save instance to persist it

        item1 = QuotationItem(
            quotation=quotation,
            description="Product 1",
            quantity=2,
            unit_price=Decimal('25.00')
        )
        item1.save()  # Save item instance to persist it

        item2 = QuotationItem(
            quotation=quotation,
            description="Product 2",
            quantity=3,
            unit_price=Decimal('10.00')
        )
        item2.save()  # Save item instance to persist it

        # Recalculate totals
        quotation.calculate_totals()
        assert quotation.subtotal == Decimal(80.00)  # (2*25 + 3*10)
        expected_total_tax = Decimal('10.40').quantize(Decimal('0.01'))
        assert quotation.total_tax == expected_total_tax
        expected_grand_total = Decimal('114.40').quantize(Decimal('0.01'))
        assert quotation.grand_total == expected_grand_total
        

    def test_invalid_email(self):
        """Test for invalid email addresses."""
        with pytest.raises(ValidationError):
            quotation = Quotation(
                client_name="Jane Doe",
                client_email="invalid-email",  # Invalid email
                client_address="456 Another St",
                client_phone_number="555-5678"
            )
            quotation.full_clean()  # Triggers the email validation

    def test_required_fields(self):
        """Test required fields in Quotation model."""
        with pytest.raises(ValidationError):
            quotation = Quotation(
                client_email="jane@example.com",
                client_address="456 Another St",
                client_phone_number="555-5678"
            )
            quotation.full_clean()  # Missing client_name should raise ValidationError

# tests for form validation logic begin here
@pytest.mark.django_db
class TestQuotationForm: # validations for QuotationForm

    def test_valid_quotation_form(self):
        # Set up a quotation with necessary fields, excluding `labour_cost`
        quotation = Quotation(
            client_name="John Doe",
            client_email="john@example.com",
            client_address="123 Main St",
            client_phone_number="555-1234",
            tax_rate=Decimal('10.00'),
            status="Draft",
            date_created=timezone.now(),
            valid_until=timezone.now().date() + timezone.timedelta(days=30)
        )
        quotation.save()

        # Add items to ensure `labour_cost` and subtotal are calculated
        QuotationItem.objects.create(
            quotation=quotation,
            description="Item 1",
            quantity=2,
            unit_price=Decimal('25.00')
        )

        quotation.calculate_totals()
        assert quotation.labour_cost == quotation.subtotal * Decimal('0.30')
        
    def test_invalid_tax_rate(self):
        form_data = {
            'client_name': "Jane Doe",
            'client_email': "jane@example.com",
            'client_address': "456 Elm St",
            'client_phone_number': "555-5678",
            'tax_rate': Decimal('25.00'),  # Invalid tax rate
            'valid_until': date.today() + timedelta(days=30),
            'status': 'Draft',
        }
        form = QuotationForm(data=form_data)
        assert not form.is_valid()
        assert "tax_rate" in form.errors  # Check that tax rate error is in the form errors

    
    def test_invalid_valid_until_date(self):
        """Test that a validation error is raised if 'valid_until' is before 'date_created'."""
        date_created = timezone.now()

        # Prepare form data with an invalid 'valid_until' date
        form_data = {
            'client_name': "Jane Doe",
            'client_email': "jane@example.com",
            'client_address': "456 Elm St",
            'client_phone_number': "555-6789",
            'tax_rate': Decimal('10.00'),
            'status': 'Draft',
            'valid_until': date_created.date() - timezone.timedelta(days=1),  # Invalid: before date_created
            'date_created': date_created.date(),
        }

        # Use the form to validate the data
        form = QuotationForm(data=form_data)
        form.is_valid()  # Run validation

        # Assert that the specific error is in form.errors for 'valid_until'
        assert "The valid until date must be after the date created." in form.errors["valid_until"]


@pytest.mark.django_db
class TestQuotationForm: # Validation for QuotationItemForm
    def test_valid_quotation_item_form(self):
        form_data = {
            'description': 'Test Item',
            'quantity': 5,
            'unit_price': Decimal('10.00'),
        }
        form = QuotationItemForm(data=form_data)
        assert form.is_valid()  # Should pass with valid data

    def test_invalid_quantity(self):
        form_data = {
            'description': 'Test Item',
            'quantity': -3,  # Invalid negative quantity
            'unit_price': Decimal('10.00'),
        }
        form = QuotationItemForm(data=form_data)
        assert not form.is_valid()
        assert "quantity" in form.errors

    def test_invalid_unit_price(self):
        form_data = {
            'description': 'Test Item',
            'quantity': 3,
            'unit_price': Decimal('-5.00'),  # Invalid negative price
        }
        form = QuotationItemForm(data=form_data)
        assert not form.is_valid()
        assert "unit_price" in form.errors
    
    # we include grandtotal validation in this class

    def test_grand_total_validation(self):
        """Test grand_total calculation and validation with added QuotationItems."""
        
        # Set up a subtotal (implicitly 0 without items)
        date_created = timezone.now()
        valid_until = date_created.date() + timezone.timedelta(days=30)
        
        # Create a Quotation instance
        quotation = Quotation(
            client_name="John Doe",
            client_email="john@example.com",
            client_address="123 Main St",
            client_phone_number="555-1234",
            tax_rate=Decimal('10.00'),
            date_created=date_created,
            valid_until=valid_until
        )
        quotation.save()

        # Add items to the quotation
        QuotationItem.objects.create(
            quotation=quotation,
            description="Product 1",
            quantity=2,
            unit_price=Decimal('50.00')
        )
        QuotationItem.objects.create(
            quotation=quotation,
            description="Product 2",
            quantity=3,
            unit_price=Decimal('30.00')
        )

        # Recalculate totals after adding items
        quotation.calculate_totals()
        
        # Expected calculations
        expected_subtotal = Decimal('50.00') * 2 + Decimal('30.00') * 3  # = 190.00
        expected_labour_cost = expected_subtotal * Decimal('0.30')        # = 57.00
        expected_total_tax = (expected_subtotal + expected_labour_cost) * Decimal('0.10')  # = 24.70
        expected_grand_total = expected_subtotal + expected_labour_cost + expected_total_tax  # = 271.70

        # Assertions
        assert quotation.subtotal == expected_subtotal
        assert quotation.labour_cost == expected_labour_cost
        assert quotation.total_tax == expected_total_tax
        assert quotation.grand_total == expected_grand_total


@pytest.mark.django_db
class TestQuotationViews:

    def setup_method(self):
        self.client = Client()

    def test_quotation_list_view(self):
        """Test that the quotation list view renders correctly."""
        url = reverse('quotation_list')
        response = self.client.get(url)
        assert response.status_code == 200
        assert 'quotations' in response.context  # Context contains quotations


# Invoicing module tests begin here

@pytest.mark.django_db
class TestInvoiceModel:

    def test_invoice_creation_from_quotation(self):
       
        """Test that an Invoice is correctly created from a Quotation, with all totals matching."""

        # Create and save the quotation instance
        quotation = Quotation(
            client_name="John Doe",
            client_email="john@example.com",
            client_address="123 Main St",
            client_phone_number="555-1234",
            tax_rate=Decimal('10.00'),
        )
        quotation.save()

        # Create and add items to the quotation
        item1 = QuotationItem(quotation=quotation, description="Product 1", quantity=2, unit_price=Decimal('25.00'))
        item1.save()

        item2 = QuotationItem(quotation=quotation, description="Product 2", quantity=3, unit_price=Decimal('10.00'))
        item2.save()

        # Calculate and persist totals in the quotation
        quotation.calculate_totals()
        quotation.save()
        
        # Refresh to get the latest values from the database
        quotation.refresh_from_db()

        # Create the invoice from the quotation
        invoice = Invoice(quotation=quotation)
        invoice.save()

        # Refresh the invoice from the database
        invoice.refresh_from_db()

        # Assertions to verify totals are accurately copied
        assert invoice.client_name == quotation.client_name
        assert invoice.client_email == quotation.client_email
        assert invoice.client_address == quotation.client_address
        assert invoice.subtotal == quotation.subtotal
        assert invoice.grand_total == quotation.grand_total


    def test_invoice_custom_items(self):
        """Test Invoice creation with custom items."""
        # Create invoice instance without saving yet
        invoice = Invoice(
            client_name="Custom Client",
            client_email="custom@example.com",
            client_address="456 Another St",
            client_phone_number="555-5678",
            tax_rate=Decimal('15.00')
        )
        invoice.save()  # Save the invoice to generate a unique ID

        # Create custom invoice item
        InvoiceItem.objects.create(
            invoice=invoice,
            description="Custom Service",
            quantity=1,
            unit_price=Decimal('150.00')
        )

        # Calculate totals and check the grand total
        invoice.calculate_totals()
        expected_grand_total = Decimal('150.00') * Decimal('1.15')  # Includes 15% tax
        assert invoice.grand_total == expected_grand_total

    def test_invoice_totals_calculation(self):
        """Test that Invoice totals are calculated correctly."""
        # Create invoice instance without saving yet
        invoice = Invoice(
            client_name="Client X",
            client_email="clientx@example.com",
            tax_rate=Decimal('10.00')
        )
        invoice.save()  # Save the invoice to generate a unique ID
        
        # Create invoice items
        InvoiceItem.objects.create(
            invoice=invoice,
            description="Item 1",
            quantity=3,
            unit_price=Decimal('50.00')
        )
        InvoiceItem.objects.create(
            invoice=invoice,
            description="Item 2",
            quantity=4,
            unit_price=Decimal('20.00')
        )

        # Calculate totals and check the values
        invoice.calculate_totals()
        expected_subtotal = Decimal('150.00') + Decimal('80.00')
        expected_grand_total = expected_subtotal * Decimal('1.10')
        
        assert invoice.subtotal == expected_subtotal
        assert invoice.grand_total == expected_grand_total


@pytest.mark.django_db
class TestInvoiceForm:

    def test_valid_invoice_form(self):
        """Test form validation with valid data."""
        form_data = {
            'client_name': "Valid Client",
            'client_email': "valid@example.com",
            'client_address': "123 Main St",
            'client_phone_number': "555-1234",
            'tax_rate': Decimal('5.00'),
            'date_created': date.today(),
            'due_date': date.today() + timedelta(days=30),
            'status': 'Draft'
        }
        form = InvoiceForm(data=form_data)
        print(form.errors)
        assert form.is_valid()

    def test_invalid_due_date(self):
        """Test that a ValidationError is raised if 'due_date' is before 'date_created'."""
        form_data = {
            'client_name': "Jane Doe",
            'client_email': "jane@example.com",
            'tax_rate': Decimal('10.00'),
            'date_created': date.today(),
            'due_date': date.today() - timedelta(days=5),  # Invalid due_date before date_created
        }
        form = InvoiceForm(data=form_data)
        assert not form.is_valid()
        assert "due_date" in form.errors

    def test_invalid_tax_rate(self):
        """Test that the form validates the tax rate correctly."""
        form_data = {
            'client_name': "Tax Test Client",
            'client_email': "tax@test.com",
            'tax_rate': Decimal('200.00')  # Invalid tax rate exceeding 100%
        }
        form = InvoiceForm(data=form_data)
        assert not form.is_valid()
        assert "tax_rate" in form.errors


@pytest.mark.django_db
class TestInvoiceViews:

    def setup_method(self):
        self.client = Client()

    def test_invoice_list_view(self):
        """Test that the invoice list view renders correctly."""
        url = reverse('invoice_list')
        response = self.client.get(url)
        assert response.status_code == 200
        assert 'invoices' in response.context  # Context contains invoices

    def test_invoice_creation_view(self):
        """Test that the invoice creation view works as expected."""
        url = reverse('invoice_create')
        response = self.client.get(url)
        assert response.status_code == 200
        assert 'form' in response.context  # Context should include a form instance

    def test_invoice_detail_view(self):
        """Test viewing an individual Invoice's details."""
        # Set up a sample Invoice
        invoice = Invoice(
            client_name="Detail Test Client",
            client_email="detail@example.com",
            tax_rate=Decimal('8.00')
        )
        invoice.save()

        # Add items to the Invoice
        InvoiceItem.objects.create(
            invoice=invoice,
            description="Test Service",
            quantity=1,
            unit_price=Decimal('100.00')
        )
        
        # Fetch the detail view
        url = reverse('invoice_detail', args=[invoice.id])
        response = self.client.get(url)
        
        assert response.status_code == 200
        assert 'invoice' in response.context  # Context contains the invoice instance