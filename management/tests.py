import pytest
from decimal import Decimal
from django.core.exceptions import ValidationError
from .models import Quotation, QuotationItem
from unittest import mock
from django.db import connection
import logging

logger = logging.getLogger(__name__)

@pytest.mark.django_db
class TestQuotationModel:

    @pytest.fixture(autouse=True)
    def reset_database(self, db):
        # This will run before each test
        Quotation.objects.all().delete()
        QuotationItem.objects.all().delete()
        # Optionally reset sequences
        with connection.cursor() as cursor:
            cursor.execute("ALTER SEQUENCE management_quotation_id_seq RESTART WITH 1;")
            cursor.execute("ALTER SEQUENCE management_quotationitem_id_seq RESTART WITH 1;")
    
    def test_database_state(self):
        """Log the initial state of the database."""
        logger.debug("Starting database state:")
        for quote in Quotation.objects.all():
            logger.debug(f"{quote.id} - {quote.quote_number}")

    def test_quotation_creation(self):
        """Test for creating a quotation."""
        try:
            quotation = Quotation(
                client_name="John Doe",
                client_email="john@example.com",
                client_address="123 Main St",
                client_phone_number="555-1234",
                tax_rate=Decimal('10.00'),
                labour_cost=Decimal('50.00')
            )
            quotation.save()  # Explicitly save the instance

            # Call calculate_totals to update the subtotal and grand_total
            quotation.calculate_totals()
            
            # Verify that the quote number is generated by the model's logic
            assert quotation.quote_number.startswith("QUOTE-")
            assert quotation.client_name == "John Doe"
            assert quotation.client_email == "john@example.com"
            assert quotation.subtotal == 0  # Check subtotal after totals are calculated
            assert quotation.grand_total == 50  # Expected to include only labour_cost as subtotal
        except Exception as e:
            logger.error(f"Error during test: {e}")
            raise


    def test_generate_unique_quote_number(self):
        """Test that each Quotation has a unique quote number."""
        quotation1 = Quotation(
            client_name="Client One",
            client_email="client1@example.com",
            client_address="Address One",
            client_phone_number="12345"
        )
        quotation1.save()  # Save instance to persist it

        quotation2 = Quotation(
            client_name="Client Two",
            client_email="client2@example.com",
            client_address="Address Two",
            client_phone_number="67890"
        )
        quotation2.save()  # Save instance to persist it

        assert quotation1.quote_number != quotation2.quote_number

    def test_quotation_totals_calculation(self):
        """Test total calculations for a Quotation."""
        quotation = Quotation(
            client_name="John Doe",
            client_email="john@example.com",
            client_address="123 Main St",
            client_phone_number="555-1234",
            tax_rate=Decimal('10.00'),
            labour_cost=Decimal('50.00')
        )
        quotation.save()  # Save instance to persist it

        item1 = QuotationItem(
            quotation=quotation,
            description="Product 1",
            quantity=2,
            unit_price=Decimal('25.00')
        )
        item1.save()  # Save item instance to persist it

        item2 = QuotationItem(
            quotation=quotation,
            description="Product 2",
            quantity=3,
            unit_price=Decimal('10.00')
        )
        item2.save()  # Save item instance to persist it

        # Recalculate totals
        quotation.calculate_totals()
        assert quotation.subtotal == 80  # (2*25 + 3*10)
        assert quotation.total_tax == 8   # 10% of subtotal
        assert quotation.grand_total == 138  # subtotal + tax + labor cost

    def test_invalid_email(self):
        """Test for invalid email addresses."""
        with pytest.raises(ValidationError):
            quotation = Quotation(
                client_name="Jane Doe",
                client_email="invalid-email",  # Invalid email
                client_address="456 Another St",
                client_phone_number="555-5678"
            )
            quotation.full_clean()  # Triggers the email validation

    def test_required_fields(self):
        """Test required fields in Quotation model."""
        with pytest.raises(ValidationError):
            quotation = Quotation(
                client_email="jane@example.com",
                client_address="456 Another St",
                client_phone_number="555-5678"
            )
            quotation.full_clean()  # Missing client_name should raise ValidationError
